/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TagsColorFilesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// i18n.ts
var import_obsidian = require("obsidian");

// locales/en.ts
var en_default = {
  SETTINGS_TITLE: "Tags Color Files Settings",
  PLUGIN_DESCRIPTION: "Tags Color Files highlights files in the Obsidian file explorer based on rules you define. When a tag with a corresponding rule is added to a file, it automatically changes to the specified color.",
  GENERAL_SECTION: "General",
  COLOR_METHOD_NAME: "Coloring Method",
  COLOR_METHOD_DESC: 'When "Dots Before Text" is selected, multiple colors can be displayed simultaneously.',
  COLOR_TEXT: "Text",
  COLOR_BG: "Background",
  COLOR_DOTS_BEFORE: "Dots Before Text",
  COLOR_DOTS_AFTER: "Dots After Text",
  BACKUP_RESTORE: "Backup & Restore",
  EXPORT: "Export Settings",
  IMPORT: "Import Settings",
  EXPORTED: "Exported successfully!",
  IMPORTED: "Imported successfully!",
  INVALID_FILE: "Error: Invalid file",
  RULES_SECTION: "Coloring Rules",
  ADD_RULE_NAME: "Add Coloring Rule",
  ADD_RULE_DESC: "Enter a tag and choose a highlight color. Note: If a file has multiple tags with rules, the priority is determined by the order in this list.",
  ADD_RULE_BTN: "New Rule",
  TAG_PLACEHOLDER: "#tag"
};

// locales/ru.ts
var ru_default = {
  SETTINGS_TITLE: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 Tags Color Files",
  PLUGIN_DESCRIPTION: "Tags Color Files \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0444\u0430\u0439\u043B\u044B \u0432 \u043F\u0440\u043E\u0432\u043E\u0434\u043D\u0438\u043A\u0435 Obsidian \u0441\u043E\u0433\u043B\u0430\u0441\u043D\u043E \u0437\u0430\u0434\u0430\u043D\u043D\u044B\u043C \u0432\u0430\u043C\u0438 \u043F\u0440\u0430\u0432\u0438\u043B\u0430\u043C. \u041F\u0440\u0438 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0438\u0438 \u043A \u0444\u0430\u0439\u043B\u0443 \u0442\u0435\u0433\u0430, \u0434\u043B\u044F \u043A\u043E\u0442\u043E\u0440\u043E\u0433\u043E \u0441\u043E\u0437\u0434\u0430\u043D\u043E \u043F\u0440\u0430\u0432\u0438\u043B\u043E, \u043E\u043D \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0432 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0439 \u0446\u0432\u0435\u0442.",
  GENERAL_SECTION: "\u041E\u0441\u043D\u043E\u0432\u043D\u044B\u0435",
  COLOR_METHOD_NAME: "\u0421\u043F\u043E\u0441\u043E\u0431 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F",
  COLOR_METHOD_DESC: '\u0415\u0441\u043B\u0438 \u0432\u044B\u0431\u0440\u0430\u043D \u0432\u0430\u0440\u0438\u0430\u043D\u0442 "\u0422\u043E\u0447\u043A\u0438 \u043F\u0435\u0440\u0435\u0434 \u0442\u0435\u043A\u0441\u0442\u043E\u043C", \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0435\u0442\u0441\u044F \u0441\u0440\u0430\u0437\u0443 \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0446\u0432\u0435\u0442\u043E\u0432.',
  COLOR_TEXT: "\u0422\u0435\u043A\u0441\u0442",
  COLOR_BG: "\u0424\u043E\u043D",
  COLOR_DOTS_BEFORE: "\u0422\u043E\u0447\u043A\u0438 \u043F\u0435\u0440\u0435\u0434 \u0442\u0435\u043A\u0441\u0442\u043E\u043C",
  COLOR_DOTS_AFTER: "\u0422\u043E\u0447\u043A\u0438 \u043F\u043E\u0441\u043B\u0435 \u0442\u0435\u043A\u0441\u0442\u0430",
  BACKUP_RESTORE: "\u0420\u0435\u0437\u0435\u0440\u0432\u043D\u043E\u0435 \u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0438 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435",
  EXPORT: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043A",
  IMPORT: "\u0418\u043C\u043F\u043E\u0440\u0442 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043A",
  EXPORTED: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u043E!",
  IMPORTED: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E \u0438\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u043E!",
  INVALID_FILE: "\u041E\u0448\u0438\u0431\u043A\u0430: \u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u0444\u0430\u0439\u043B",
  RULES_SECTION: "\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F",
  ADD_RULE_NAME: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u043E \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F",
  ADD_RULE_DESC: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u0433 \u0438 \u0443\u043A\u0430\u0436\u0438\u0442\u0435 \u0446\u0432\u0435\u0442 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432. \u041E\u0431\u0440\u0430\u0442\u0438\u0442\u0435 \u0432\u043D\u0438\u043C\u0430\u043D\u0438\u0435: \u0415\u0441\u043B\u0438 \u043A \u0444\u0430\u0439\u043B\u0443 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043E \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0442\u0435\u0433\u043E\u0432, \u0434\u043B\u044F \u043A\u043E\u0442\u043E\u0440\u044B\u0445 \u0441\u043E\u0437\u0434\u0430\u043D\u043E \u043F\u0440\u0430\u0432\u0438\u043B\u043E, \u0432\u044B\u0431\u0438\u0440\u0430\u0435\u0442\u0441\u044F \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442\u043D\u044B\u0439.",
  ADD_RULE_BTN: "\u041D\u043E\u0432\u043E\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u043E",
  TAG_PLACEHOLDER: "#\u0442\u0435\u0433"
};

// i18n.ts
var localeMap = {
  en: en_default,
  ru: ru_default
  // Add other mappings here
};
var t = (key) => {
  const lang = import_obsidian.moment.locale();
  const targetLocale = localeMap[lang] || localeMap["en"];
  return targetLocale[key] || localeMap["en"][key] || key;
};

// main.ts
var DEFAULT_SETTINGS = {
  tagColors: [],
  colorStrategy: "text"
};
var TagsColorFilesPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.isUpdating = false;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new TagsColorFilesSettingTab(this.app, this));
    this.registerEvent(this.app.metadataCache.on("changed", () => this.updateFileColors()));
    this.registerEvent(this.app.vault.on("rename", () => this.updateFileColors()));
    this.registerEvent(this.app.workspace.on("layout-change", () => this.updateFileColors()));
    this.observer = new MutationObserver((mutations) => {
      if (this.isUpdating)
        return;
      let shouldUpdate = false;
      for (const m of mutations) {
        for (const node of Array.from(m.addedNodes)) {
          if (node instanceof HTMLElement && (node.classList.contains("nav-file") || node.querySelector(".nav-file-title"))) {
            shouldUpdate = true;
            break;
          }
        }
        if (shouldUpdate)
          break;
      }
      if (shouldUpdate)
        this.updateFileColors();
    });
    this.app.workspace.onLayoutReady(() => {
      this.observer.observe(document.body, { childList: true, subtree: true });
      setTimeout(() => this.updateFileColors(), 500);
    });
  }
  onunload() {
    if (this.observer)
      this.observer.disconnect();
    this.removeFileColors();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    this.settings.tagColors = this.settings.tagColors.filter((rule) => rule.tag && rule.tag.trim() !== "");
    await this.saveData(this.settings);
    this.updateFileColors();
  }
  removeFileColors() {
    const fileExplorers = this.app.workspace.getLeavesOfType("file-explorer");
    fileExplorers.forEach((leaf) => {
      const navFiles = leaf.view.containerEl.querySelectorAll(".nav-file-title");
      navFiles.forEach((el) => this.cleanElement(el));
    });
  }
  cleanElement(el) {
    el.style.removeProperty("color");
    el.style.removeProperty("background-color");
    el.style.removeProperty("border-radius");
    el.classList.remove("colored-tag-file");
    const existingDots = el.querySelector(".tag-dots-container");
    if (existingDots)
      existingDots.remove();
  }
  updateFileColors() {
    if (this.isUpdating)
      return;
    window.requestAnimationFrame(() => {
      this.isUpdating = true;
      const fileExplorers = this.app.workspace.getLeavesOfType("file-explorer");
      fileExplorers.forEach((leaf) => {
        const navFiles = leaf.view.containerEl.querySelectorAll(".nav-file-title");
        navFiles.forEach((el) => {
          const path = el.getAttribute("data-path");
          if (!path)
            return;
          const file = this.app.vault.getAbstractFileByPath(path);
          if (file instanceof import_obsidian2.TFile) {
            const cache = this.app.metadataCache.getFileCache(file);
            const fileTags = (0, import_obsidian2.getAllTags)(cache);
            this.cleanElement(el);
            if (!fileTags || this.settings.tagColors.length === 0)
              return;
            const matchedColors = [];
            for (const config of this.settings.tagColors) {
              if (!config.tag)
                continue;
              const normalizeConfigTag = config.tag.startsWith("#") ? config.tag : "#" + config.tag;
              if (fileTags.some((t2) => t2.toLowerCase() === normalizeConfigTag.toLowerCase())) {
                matchedColors.push(config.color);
              }
            }
            if (matchedColors.length > 0) {
              el.classList.add("colored-tag-file");
              if (this.settings.colorStrategy === "text") {
                el.style.color = matchedColors[0];
              } else if (this.settings.colorStrategy === "background") {
                el.style.backgroundColor = matchedColors[0];
                el.style.borderRadius = "4px";
              } else if (this.settings.colorStrategy === "before-text" || this.settings.colorStrategy === "after-text") {
                const dotsContainer = document.createElement("div");
                const isBefore = this.settings.colorStrategy === "before-text";
                dotsContainer.className = `tag-dots-container ${isBefore ? "is-before" : "is-after"}`;
                matchedColors.slice(0, 3).forEach((color, i) => {
                  const dot = document.createElement("div");
                  dot.className = "tag-dot";
                  dot.style.backgroundColor = color;
                  if (isBefore) {
                    dot.style.right = `${-16 + i * 5}px`;
                  } else {
                    dot.style.right = `${10 + i * 5}px`;
                  }
                  dot.style.zIndex = `${20 - i}`;
                  dotsContainer.appendChild(dot);
                });
                el.appendChild(dotsContainer);
              }
            }
          }
        });
      });
      this.isUpdating = false;
    });
  }
};
var TagsColorFilesSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.draggingIndex = null;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: t("SETTINGS_TITLE") });
    containerEl.createEl("p", { text: t("PLUGIN_DESCRIPTION"), cls: "setting-item-description" });
    containerEl.createEl("h3", { text: t("GENERAL_SECTION") });
    new import_obsidian2.Setting(containerEl).setName(t("COLOR_METHOD_NAME")).setDesc(t("COLOR_METHOD_DESC")).addDropdown((dropdown) => {
      dropdown.addOption("text", t("COLOR_TEXT")).addOption("background", t("COLOR_BG")).addOption("before-text", t("COLOR_DOTS_BEFORE")).addOption("after-text", t("COLOR_DOTS_AFTER")).setValue(this.plugin.settings.colorStrategy).onChange(async (value) => {
        this.plugin.settings.colorStrategy = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName(t("BACKUP_RESTORE")).addButton((btn) => btn.setButtonText(t("EXPORT")).onClick(() => {
      const data = JSON.stringify(this.plugin.settings.tagColors, null, 2);
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `tags-color-settings.json`;
      a.click();
      URL.revokeObjectURL(url);
      new import_obsidian2.Notice(t("EXPORTED"));
    })).addButton((btn) => btn.setButtonText(t("IMPORT")).onClick(() => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file)
          return;
        const reader = new FileReader();
        reader.onload = async (event) => {
          try {
            const parsed = JSON.parse(event.target.result);
            if (Array.isArray(parsed)) {
              this.plugin.settings.tagColors = parsed;
              await this.plugin.saveSettings();
              this.display();
              new import_obsidian2.Notice(t("IMPORTED"));
            }
          } catch (err) {
            new import_obsidian2.Notice(t("INVALID_FILE"));
          }
        };
        reader.readAsText(file);
      };
      input.click();
    }));
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: t("RULES_SECTION") });
    new import_obsidian2.Setting(containerEl).setName(t("ADD_RULE_NAME")).setDesc(t("ADD_RULE_DESC")).addButton(
      (btn) => btn.setButtonText(t("ADD_RULE_BTN")).setCta().onClick(async () => {
        this.plugin.settings.tagColors.unshift({ tag: "", color: "#4a90e2" });
        this.display();
      })
    );
    const rulesContainer = containerEl.createDiv({ cls: "tag-rules-list" });
    this.plugin.settings.tagColors.forEach((config, index) => {
      const div = rulesContainer.createDiv({ cls: "tag-color-setting-item" });
      div.draggable = true;
      div.addEventListener("dragstart", (e) => {
        this.draggingIndex = index;
        div.addClass("is-dragging");
      });
      div.addEventListener("dragend", () => {
        this.draggingIndex = null;
        div.removeClass("is-dragging");
        this.display();
      });
      div.addEventListener("dragover", (e) => {
        e.preventDefault();
        div.addClass("drag-over");
      });
      div.addEventListener("dragleave", () => div.removeClass("drag-over"));
      div.addEventListener("drop", async (e) => {
        e.preventDefault();
        if (this.draggingIndex === null || this.draggingIndex === index)
          return;
        const movedItem = this.plugin.settings.tagColors.splice(this.draggingIndex, 1)[0];
        this.plugin.settings.tagColors.splice(index, 0, movedItem);
        await this.plugin.saveSettings();
        this.display();
      });
      const dragHandle = div.createEl("div", { cls: "clickable-icon drag-handle" });
      (0, import_obsidian2.setIcon)(dragHandle, "lucide-grip-vertical");
      const cp = document.createElement("input");
      cp.type = "color";
      cp.value = config.color;
      cp.addClass("tag-color-picker-input");
      cp.onchange = async (e) => {
        config.color = e.target.value;
        await this.plugin.saveSettings();
      };
      div.appendChild(cp);
      const txt = document.createElement("input");
      txt.type = "text";
      txt.value = config.tag;
      txt.placeholder = t("TAG_PLACEHOLDER");
      txt.onchange = async (e) => {
        config.tag = e.target.value;
        await this.plugin.saveSettings();
      };
      div.appendChild(txt);
      const del = div.createEl("button", { cls: "clickable-icon" });
      (0, import_obsidian2.setIcon)(del, "trash");
      del.onclick = async () => {
        this.plugin.settings.tagColors.splice(index, 1);
        await this.plugin.saveSettings();
        this.display();
      };
    });
  }
};
