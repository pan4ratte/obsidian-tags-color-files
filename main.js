/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TagsColorFilesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// locales-list.ts
var import_obsidian = require("obsidian");

// locales/en.ts
var en_default = {
  SETTINGS_TITLE: "Tags Color Files settings",
  PLUGIN_DESCRIPTION: "Tags Color Files highlights files in your Obsidian file explorer based on predefined coloring rules. When you add a tag that has a corresponding coloring rule to a file, the plugin automatically highlights that file in the file explorer with predefined color.",
  GENERAL_SECTION: "General",
  COLOR_METHOD_NAME: "Coloring method",
  COLOR_METHOD_DESC: 'If "Dots before text" or "Dots after text" is selected, multiple colored dots will be displayed simultaneously if the file has more that one tag with predefined coloring rule.',
  COLOR_TEXT: "Text",
  COLOR_BG: "Background",
  COLOR_DOTS_BEFORE: "Dots before text",
  COLOR_DOTS_AFTER: "Dots after text",
  BACKUP_RESTORE: "Backup & restore",
  DOT_SIZE_NAME: "Dots size",
  DOT_SIZE_DESC: 'Choose the size of dots for "Dots before/after Text" coloring methods.',
  DOT_SMALL: "Small",
  DOT_DEFAULT: "Default",
  DOT_BIG: "Big",
  EXPORT: "Export settings",
  IMPORT: "Import settings",
  EXPORTED: "Exported successfully!",
  IMPORTED: "Imported successfully!",
  INVALID_FILE: "Error: Invalid file",
  RULES_SECTION: "Coloring rules",
  ADD_RULE_NAME: "Add coloring rule",
  ADD_RULE_DESC: "Enter a tag and choose a highlight color. If a file has multiple tags for which there is a rule, the highest priority rule is picked for coloring: rules at the top of the list have the highest priority.",
  ADD_RULE_BTN: "New rule",
  TAG_PLACEHOLDER: "Enter a tag (case-insensitive)",
  DUPLICATE_TAG_ERROR: "There is already a rule for this tag! Choose another tag.",
  INVALID_TAG_ERROR: "Invalid tag name"
};

// locales/ru.ts
var ru_default = {
  SETTINGS_TITLE: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 Tags Color Files",
  PLUGIN_DESCRIPTION: "Tags Color Files \u0432\u044B\u0434\u0435\u043B\u044F\u0435\u0442 \u0444\u0430\u0439\u043B\u044B \u0432 \u043F\u0440\u043E\u0432\u043E\u0434\u043D\u0438\u043A\u0435 Obsidian \u0441\u043E\u0433\u043B\u0430\u0441\u043D\u043E \u0437\u0430\u0434\u0430\u043D\u043D\u044B\u043C \u0432\u0430\u043C\u0438 \u043F\u0440\u0430\u0432\u0438\u043B\u0430\u043C \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F. \u041F\u0440\u0438 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0438\u0438 \u043A \u0444\u0430\u0439\u043B\u0443 \u0442\u0435\u0433\u0430, \u0434\u043B\u044F \u043A\u043E\u0442\u043E\u0440\u043E\u0433\u043E \u0441\u043E\u0437\u0434\u0430\u043D\u043E \u043F\u0440\u0430\u0432\u0438\u043B\u043E, \u043F\u043B\u0430\u0433\u0438\u043D \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u0442 \u0435\u0433\u043E \u0432 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0439 \u0446\u0432\u0435\u0442 \u0432 \u043F\u0440\u043E\u0432\u043E\u0434\u043D\u0438\u043A\u0435.",
  GENERAL_SECTION: "\u041E\u0441\u043D\u043E\u0432\u043D\u044B\u0435",
  COLOR_METHOD_NAME: "\u0421\u043F\u043E\u0441\u043E\u0431 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F",
  COLOR_METHOD_DESC: '\u0415\u0441\u043B\u0438 \u0432\u044B\u0431\u0440\u0430\u043D \u0432\u0430\u0440\u0438\u0430\u043D\u0442 "\u0422\u043E\u0447\u043A\u0438 \u043F\u0435\u0440\u0435\u0434 \u0442\u0435\u043A\u0441\u0442\u043E\u043C" \u0438\u043B\u0438 "\u0422\u043E\u0447\u043A\u0438 \u043F\u043E\u0441\u043B\u0435 \u0442\u0435\u043A\u0441\u0442\u0430", \u0434\u043E \u0442\u0440\u0451\u0445 \u0446\u0432\u0435\u0442\u043D\u044B\u0445 \u0442\u043E\u0447\u0435\u043A \u0431\u0443\u0434\u0443\u0442 \u043E\u0434\u043D\u043E\u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C\u0441\u044F, \u0435\u0441\u043B\u0438 \u0432 \u0444\u0430\u0439\u043B\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044F \u0431\u043E\u043B\u044C\u0448\u0435 \u043E\u0434\u043D\u043E\u0433\u043E \u0442\u0435\u0433\u0430, \u0434\u043B\u044F \u043A\u043E\u0442\u043E\u0440\u043E\u0433\u043E \u0441\u043E\u0437\u0434\u0430\u043D\u043E \u043F\u0440\u0430\u0432\u0438\u043B\u043E \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F.',
  COLOR_TEXT: "\u0422\u0435\u043A\u0441\u0442",
  COLOR_BG: "\u0424\u043E\u043D",
  COLOR_DOTS_BEFORE: "\u0422\u043E\u0447\u043A\u0438 \u043F\u0435\u0440\u0435\u0434 \u0442\u0435\u043A\u0441\u0442\u043E\u043C",
  COLOR_DOTS_AFTER: "\u0422\u043E\u0447\u043A\u0438 \u043F\u043E\u0441\u043B\u0435 \u0442\u0435\u043A\u0441\u0442\u0430",
  DOT_SIZE_NAME: "\u0420\u0430\u0437\u043C\u0435\u0440 \u0442\u043E\u0447\u0435\u043A",
  DOT_SIZE_DESC: '\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0440\u0430\u0437\u043C\u0435\u0440 \u0446\u0432\u0435\u0442\u043D\u044B\u0445 \u0442\u043E\u0447\u0435\u043A \u0434\u043B\u044F \u043C\u0435\u0442\u043E\u0434\u043E\u0432 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F "\u0422\u043E\u0447\u043A\u0438 \u043F\u0435\u0440\u0435\u0434/\u043F\u043E\u0441\u043B\u0435 \u0442\u0435\u043A\u0441\u0442\u0430".',
  DOT_SMALL: "\u041C\u0430\u043B\u0435\u043D\u044C\u043A\u0438\u0435",
  DOT_DEFAULT: "\u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
  DOT_BIG: "\u0411\u043E\u043B\u044C\u0448\u0438\u0435",
  BACKUP_RESTORE: "\u0420\u0435\u0437\u0435\u0440\u0432\u043D\u043E\u0435 \u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0438 \u0432\u043E\u0441\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435",
  EXPORT: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043A",
  IMPORT: "\u0418\u043C\u043F\u043E\u0440\u0442 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043A",
  EXPORTED: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u043E!",
  IMPORTED: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E \u0438\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u043E!",
  INVALID_FILE: "\u041E\u0448\u0438\u0431\u043A\u0430: \u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 \u0444\u0430\u0439\u043B",
  RULES_SECTION: "\u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F",
  ADD_RULE_NAME: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u043E \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F",
  ADD_RULE_DESC: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u0433 \u0438 \u0443\u043A\u0430\u0436\u0438\u0442\u0435 \u0446\u0432\u0435\u0442 \u043E\u043A\u0440\u0430\u0448\u0438\u0432\u0430\u043D\u0438\u044F. \u0415\u0441\u043B\u0438 \u043A \u0444\u0430\u0439\u043B\u0443 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043E \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0442\u0435\u0433\u043E\u0432, \u0434\u043B\u044F \u043A\u043E\u0442\u043E\u0440\u044B\u0445 \u0441\u043E\u0437\u0434\u0430\u043D\u043E \u043F\u0440\u0430\u0432\u0438\u043B\u043E, \u0432\u044B\u0431\u0438\u0440\u0430\u0435\u0442\u0441\u044F \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442\u043D\u044B\u0439: \u0447\u0435\u043C \u0432\u044B\u0448\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u043E \u0432 \u0441\u043F\u0438\u0441\u043A\u0435, \u0442\u0435\u043C \u0431\u043E\u043B\u044C\u0448\u0438\u0439 \u0443 \u043D\u0435\u0433\u043E \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0435\u0442.",
  ADD_RULE_BTN: "\u041D\u043E\u0432\u043E\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u043E",
  TAG_PLACEHOLDER: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u0433 (\u0440\u0435\u0433\u0438\u0441\u0442\u0440 \u043D\u0435 \u0443\u0447\u0438\u0442\u044B\u0432\u0430\u0435\u0442\u0441\u044F)",
  DUPLICATE_TAG_ERROR: "\u0414\u043B\u044F \u044D\u0442\u043E\u0433\u043E \u0442\u0435\u0433\u0430 \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043F\u0440\u0430\u0432\u0438\u043B\u043E! \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0440\u0443\u0433\u043E\u0439 \u0442\u0435\u0433",
  INVALID_TAG_ERROR: "\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u043E\u0435 \u0438\u043C\u044F \u0442\u0435\u0433\u0430"
};

// locales-list.ts
var localeMap = {
  en: en_default,
  ru: ru_default
  // Add other mappings here
};
var t = (key) => {
  const lang = import_obsidian.moment.locale();
  const targetLocale = localeMap[lang] || localeMap["en"];
  return targetLocale[key] || localeMap["en"][key] || key;
};

// main.ts
var TagSuggest = class extends import_obsidian2.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(query) {
    const cache = this.app.metadataCache;
    const allTags = Object.keys(cache.getTags());
    const normalizedQuery = query.startsWith("#") ? query.toLowerCase() : "#" + query.toLowerCase();
    return allTags.filter((tag) => tag.toLowerCase().contains(normalizedQuery));
  }
  renderSuggestion(tag, el) {
    el.setText(tag);
  }
  selectSuggestion(tag) {
    this.inputEl.value = tag;
    this.inputEl.trigger("input");
    this.close();
  }
};
var DEFAULT_SETTINGS = {
  tagColors: [],
  colorStrategy: "text",
  dotSize: "default"
};
var TagsColorFilesPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.isUpdating = false;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new TagsColorFilesSettingTab(this.app, this));
    this.registerEvent(this.app.metadataCache.on("changed", () => this.updateFileColors()));
    this.registerEvent(this.app.vault.on("rename", () => this.updateFileColors()));
    this.registerEvent(this.app.workspace.on("layout-change", () => this.updateFileColors()));
    this.observer = new MutationObserver((mutations) => {
      if (this.isUpdating)
        return;
      let shouldUpdate = false;
      for (const m of mutations) {
        for (const node of Array.from(m.addedNodes)) {
          if (node instanceof HTMLElement && (node.classList.contains("nav-file") || node.querySelector(".nav-file-title"))) {
            shouldUpdate = true;
            break;
          }
        }
        if (shouldUpdate)
          break;
      }
      if (shouldUpdate)
        this.updateFileColors();
    });
    this.app.workspace.onLayoutReady(() => {
      this.observer.observe(document.body, { childList: true, subtree: true });
      setTimeout(() => this.updateFileColors(), 500);
    });
  }
  onunload() {
    if (this.observer)
      this.observer.disconnect();
    this.removeFileColors();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    this.settings.tagColors = this.settings.tagColors.filter((rule) => rule.tag && rule.tag.trim() !== "");
    await this.saveData(this.settings);
    this.updateFileColors();
  }
  removeFileColors() {
    const fileExplorers = this.app.workspace.getLeavesOfType("file-explorer");
    fileExplorers.forEach((leaf) => {
      const navFiles = leaf.view.containerEl.querySelectorAll(".nav-file-title");
      navFiles.forEach((el) => this.cleanElement(el));
    });
  }
  cleanElement(el) {
    el.classList.remove("colored-tag-file", "strategy-text", "strategy-background", "strategy-before-text", "strategy-after-text");
    el.style.removeProperty("--tag-file-color");
    const existingDots = el.querySelector(".tag-dots-container");
    if (existingDots)
      existingDots.remove();
  }
  updateFileColors() {
    if (this.isUpdating)
      return;
    window.requestAnimationFrame(() => {
      this.isUpdating = true;
      const fileExplorers = this.app.workspace.getLeavesOfType("file-explorer");
      fileExplorers.forEach((leaf) => {
        const navFiles = leaf.view.containerEl.querySelectorAll(".nav-file-title");
        navFiles.forEach((el) => {
          const path = el.getAttribute("data-path");
          if (!path)
            return;
          const file = this.app.vault.getAbstractFileByPath(path);
          if (file instanceof import_obsidian2.TFile) {
            const cache = this.app.metadataCache.getFileCache(file);
            const fileTags = cache ? (0, import_obsidian2.getAllTags)(cache) : null;
            this.cleanElement(el);
            if (!fileTags || this.settings.tagColors.length === 0)
              return;
            const matchedColors = [];
            for (const config of this.settings.tagColors) {
              if (!config.tag)
                continue;
              const normalizedConfig = config.tag.replace(/^#/, "").toLowerCase();
              if (fileTags.some((t2) => t2.replace(/^#/, "").toLowerCase() === normalizedConfig)) {
                matchedColors.push(config.color);
              }
            }
            if (matchedColors.length > 0) {
              el.classList.add("colored-tag-file");
              el.classList.add(`strategy-${this.settings.colorStrategy}`);
              el.style.setProperty("--tag-file-color", matchedColors[0]);
              if (this.settings.colorStrategy === "before-text" || this.settings.colorStrategy === "after-text") {
                const dotsContainer = document.createElement("div");
                const isBefore = this.settings.colorStrategy === "before-text";
                dotsContainer.className = `tag-dots-container ${isBefore ? "is-before" : "is-after"} dots-${this.settings.dotSize}`;
                matchedColors.slice(0, 3).forEach((color, i) => {
                  const dot = document.createElement("div");
                  dot.className = "tag-dot";
                  dot.style.setProperty("--dot-color", color);
                  dot.style.setProperty("--dot-index", i.toString());
                  dotsContainer.appendChild(dot);
                });
                el.appendChild(dotsContainer);
              }
            }
          }
        });
      });
      this.isUpdating = false;
    });
  }
};
var TagsColorFilesSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.draggingIndex = null;
    this.lastCreatedInput = null;
    this.ruleElements = [];
    this.plugin = plugin;
  }
  validateTagName(tag) {
    if (!tag)
      return true;
    const cleanTag = tag.replace(/^#/, "");
    if (!cleanTag)
      return true;
    const validTagRegex = /^(?!\d+$)[\p{L}\p{N}\/_-]+$/u;
    return validTagRegex.test(cleanTag);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.ruleElements = [];
    new import_obsidian2.Setting(containerEl).setName(t("SETTINGS_TITLE")).setHeading();
    const descContainer = containerEl.createDiv({ cls: "plugin-description-container" });
    descContainer.createEl("p", { text: t("PLUGIN_DESCRIPTION"), cls: "setting-item-description" });
    new import_obsidian2.Setting(containerEl).setName(t("GENERAL_SECTION")).setHeading();
    new import_obsidian2.Setting(containerEl).setName(t("COLOR_METHOD_NAME")).setDesc(t("COLOR_METHOD_DESC")).addDropdown((dropdown) => {
      dropdown.addOption("text", t("COLOR_TEXT")).addOption("background", t("COLOR_BG")).addOption("before-text", t("COLOR_DOTS_BEFORE")).addOption("after-text", t("COLOR_DOTS_AFTER")).setValue(this.plugin.settings.colorStrategy).onChange(async (value) => {
        this.plugin.settings.colorStrategy = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.colorStrategy === "before-text" || this.plugin.settings.colorStrategy === "after-text") {
      new import_obsidian2.Setting(containerEl).setName(t("DOT_SIZE_NAME")).setDesc(t("DOT_SIZE_DESC")).addDropdown((dropdown) => {
        dropdown.addOption("small", t("DOT_SMALL")).addOption("default", t("DOT_DEFAULT")).addOption("big", t("DOT_BIG")).setValue(this.plugin.settings.dotSize).onChange(async (value) => {
          this.plugin.settings.dotSize = value;
          await this.plugin.saveSettings();
        });
      });
    }
    new import_obsidian2.Setting(containerEl).setName(t("BACKUP_RESTORE")).addButton((btn) => btn.setButtonText(t("EXPORT")).onClick(() => {
      const data = JSON.stringify(this.plugin.settings.tagColors, null, 2);
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `tags-color-settings.json`;
      a.click();
      URL.revokeObjectURL(url);
      new import_obsidian2.Notice(t("EXPORTED"));
    })).addButton((btn) => btn.setButtonText(t("IMPORT")).onClick(() => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = (e) => {
        var _a;
        const target = e.target;
        const file = (_a = target.files) == null ? void 0 : _a[0];
        if (!file)
          return;
        const reader = new FileReader();
        reader.onload = (event) => {
          var _a2;
          try {
            const result = (_a2 = event.target) == null ? void 0 : _a2.result;
            if (typeof result === "string") {
              const parsed = JSON.parse(result);
              if (Array.isArray(parsed)) {
                this.plugin.settings.tagColors = parsed;
                void this.plugin.saveSettings();
                this.display();
                new import_obsidian2.Notice(t("IMPORTED"));
              }
            }
          } catch (err) {
            new import_obsidian2.Notice(t("INVALID_FILE"));
          }
        };
        reader.readAsText(file);
      };
      input.click();
    }));
    containerEl.createEl("hr");
    new import_obsidian2.Setting(containerEl).setName(t("RULES_SECTION")).setHeading();
    new import_obsidian2.Setting(containerEl).setName(t("ADD_RULE_NAME")).setDesc(t("ADD_RULE_DESC")).addButton(
      (btn) => btn.setButtonText(t("ADD_RULE_BTN")).setCta().onClick(() => {
        this.plugin.settings.tagColors.unshift({ tag: "", color: "#4a90e2" });
        this.display();
        if (this.lastCreatedInput)
          this.lastCreatedInput.focus();
      })
    );
    const rulesContainer = containerEl.createDiv({ cls: "tag-rules-list" });
    const validateAllTags = () => {
      const tagCounts = {};
      this.ruleElements.forEach((el) => {
        const val = el.txt.value.replace(/^#/, "").toLowerCase().trim();
        if (val)
          tagCounts[val] = (tagCounts[val] || 0) + 1;
      });
      this.ruleElements.forEach((el) => {
        const rawVal = el.txt.value.trim();
        const normalizedVal = rawVal.replace(/^#/, "").toLowerCase();
        const isDuplicate = normalizedVal && tagCounts[normalizedVal] > 1;
        const isValid = this.validateTagName(rawVal);
        if (isDuplicate || !isValid) {
          el.txt.addClass("is-invalid");
          el.error.addClass("is-visible");
          el.error.setText(!isValid ? t("INVALID_TAG_ERROR") : t("DUPLICATE_TAG_ERROR"));
        } else {
          el.txt.removeClass("is-invalid");
          el.error.removeClass("is-visible");
        }
      });
    };
    this.plugin.settings.tagColors.forEach((config, index) => {
      const div = rulesContainer.createDiv({ cls: "tag-color-setting-item" });
      if (import_obsidian2.Platform.isMobile) {
        const reorderContainer = div.createDiv({ cls: "tag-reorder-arrows" });
        const upBtn = reorderContainer.createEl("button", { cls: "clickable-icon" });
        (0, import_obsidian2.setIcon)(upBtn, "arrow-up");
        upBtn.onclick = () => {
          if (index > 0) {
            const movedItem = this.plugin.settings.tagColors.splice(index, 1)[0];
            this.plugin.settings.tagColors.splice(index - 1, 0, movedItem);
            void this.plugin.saveSettings();
            this.display();
          }
        };
        const downBtn = reorderContainer.createEl("button", { cls: "clickable-icon" });
        (0, import_obsidian2.setIcon)(downBtn, "arrow-down");
        downBtn.onclick = () => {
          if (index < this.plugin.settings.tagColors.length - 1) {
            const movedItem = this.plugin.settings.tagColors.splice(index, 1)[0];
            this.plugin.settings.tagColors.splice(index + 1, 0, movedItem);
            void this.plugin.saveSettings();
            this.display();
          }
        };
      } else {
        if (this.draggingIndex === index)
          div.addClass("is-dragging");
        div.draggable = true;
        const dragHandle = div.createEl("div", { cls: "clickable-icon drag-handle" });
        (0, import_obsidian2.setIcon)(dragHandle, "lucide-grip-vertical");
        div.addEventListener("dragstart", () => {
          validateAllTags();
          if (!txt.classList.contains("is-invalid") && txt.value.trim() !== "") {
            config.tag = txt.value;
            void this.plugin.saveSettings();
          }
          this.draggingIndex = index;
          div.addClass("is-dragging");
        });
        div.addEventListener("dragend", () => {
          this.draggingIndex = null;
          div.removeClass("is-dragging");
          this.display();
        });
        div.addEventListener("dragover", (e) => {
          e.preventDefault();
          if (this.draggingIndex !== null && this.draggingIndex !== index) {
            const movedItem = this.plugin.settings.tagColors.splice(this.draggingIndex, 1)[0];
            this.plugin.settings.tagColors.splice(index, 0, movedItem);
            this.draggingIndex = index;
            void this.plugin.saveSettings();
            this.display();
          }
        });
      }
      const cp = document.createElement("input");
      cp.type = "color";
      cp.value = config.color;
      cp.addClass("tag-color-picker-input");
      cp.onchange = (e) => {
        config.color = e.target.value;
        void this.plugin.saveSettings();
      };
      div.appendChild(cp);
      const inputContainer = div.createDiv({ cls: "tag-input-container" });
      const fieldWrapper = inputContainer.createDiv({ cls: "tag-input-field-wrapper" });
      const txt = document.createElement("input");
      txt.type = "text";
      txt.value = config.tag;
      txt.placeholder = t("TAG_PLACEHOLDER");
      if (index === 0)
        this.lastCreatedInput = txt;
      fieldWrapper.appendChild(txt);
      const errorMsg = inputContainer.createEl("div", { cls: "tag-error-message" });
      this.ruleElements.push({ txt, error: errorMsg });
      new TagSuggest(this.app, txt);
      txt.oninput = validateAllTags;
      txt.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          validateAllTags();
          if (!txt.classList.contains("is-invalid")) {
            config.tag = txt.value;
            void this.plugin.saveSettings();
            txt.blur();
          }
        }
      });
      txt.onchange = (e) => {
        config.tag = e.target.value;
        validateAllTags();
        void this.plugin.saveSettings();
      };
      txt.addEventListener("blur", () => {
        if (!txt.value || txt.value.trim() === "") {
          this.plugin.settings.tagColors.splice(index, 1);
          void this.plugin.saveSettings();
          this.display();
        }
      });
      const del = div.createEl("button", { cls: "clickable-icon" });
      (0, import_obsidian2.setIcon)(del, "trash");
      del.onclick = () => {
        this.plugin.settings.tagColors.splice(index, 1);
        void this.plugin.saveSettings();
        this.display();
      };
    });
    validateAllTags();
  }
};
